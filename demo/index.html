<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Songsheet Demo</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: #1a1a2e;
    color: #e0e0e0;
    min-height: 100vh;
  }

  #controls {
    position: sticky;
    top: 0;
    z-index: 10;
    background: #16213e;
    border-bottom: 1px solid #0f3460;
    padding: 12px 20px;
    display: flex;
    align-items: center;
    gap: 16px;
    flex-wrap: wrap;
  }

  #controls label {
    font-size: 13px;
    color: #a0a0c0;
  }

  select, button, input[type="range"] {
    font-size: 14px;
    border: 1px solid #0f3460;
    border-radius: 4px;
    background: #1a1a2e;
    color: #e0e0e0;
    padding: 6px 10px;
    cursor: pointer;
  }

  select { min-width: 220px; }

  button {
    background: #0f3460;
    font-weight: 600;
    min-width: 60px;
  }
  button:hover:not(:disabled) { background: #1a5276; }
  button:disabled { opacity: 0.4; cursor: default; }

  .control-group {
    display: flex;
    align-items: center;
    gap: 6px;
  }

  #bpm-value, #transpose-value {
    display: inline-block;
    min-width: 32px;
    text-align: center;
    font-variant-numeric: tabular-nums;
    color: #e94560;
    font-weight: 600;
  }

  input[type="range"] {
    width: 100px;
    padding: 0;
    cursor: pointer;
  }

  #song-display {
    max-width: 900px;
    margin: 0 auto;
    padding: 24px 20px 80px;
  }

  #song-title {
    font-size: 22px;
    font-weight: 700;
    color: #e94560;
    margin-bottom: 4px;
  }

  #song-author {
    font-size: 14px;
    color: #a0a0c0;
    margin-bottom: 24px;
  }

  .section {
    margin-bottom: 20px;
    padding: 8px 12px;
    border-radius: 6px;
    border-left: 3px solid transparent;
    transition: background 0.2s, border-color 0.2s;
  }

  .section.active-section {
    background: rgba(233, 69, 96, 0.08);
    border-left-color: #e94560;
  }

  .section-header {
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: #e94560;
    margin-bottom: 6px;
    font-weight: 600;
  }

  .line-pair {
    transition: background 0.15s;
    padding: 1px 4px;
    border-radius: 3px;
  }

  .line-pair.active-line {
    background: rgba(233, 69, 96, 0.15);
  }

  .chord-row {
    font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    font-size: 14px;
    color: #53d8fb;
    white-space: pre;
    line-height: 1.4;
    min-height: 1.4em;
  }

  .lyric-row {
    font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    font-size: 14px;
    color: #e0e0e0;
    white-space: pre;
    line-height: 1.4;
    min-height: 1.4em;
  }

  .directive-chords {
    font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    font-size: 14px;
    color: #53d8fb;
    padding: 2px 4px;
  }

  .expression-label {
    font-size: 12px;
    color: #a0a0c0;
    font-style: italic;
    margin-left: 8px;
  }

  .chord-marker {
    transition: color 0.1s, text-shadow 0.1s;
  }

  .chord-marker.active-marker {
    color: #fff;
    text-shadow: 0 0 8px #e94560, 0 0 2px #e94560;
  }

  .no-song {
    text-align: center;
    color: #a0a0c0;
    margin-top: 80px;
    font-size: 16px;
  }

  #btn-metronome {
    min-width: auto;
    padding: 6px 8px;
    font-size: 13px;
  }
  #btn-metronome.on {
    background: #e94560;
    color: #fff;
  }
</style>
</head>
<body>

<div id="controls">
  <select id="song-select">
    <option value="">Select a song...</option>
    <option value="sleeping-on-the-road.txt">Sleeping on the Road</option>
    <option value="spent-some-time-in-buffalo.txt">Spent Some Time in Buffalo</option>
    <option value="riot-on-a-screen.txt">Riot on a Screen</option>
    <option value="song-of-myself.txt">Song of Myself</option>
  </select>

  <div class="control-group">
    <button id="btn-play">Play</button>
    <button id="btn-stop" disabled>Stop</button>
    <button id="btn-metronome" title="Toggle metronome">Met.</button>
  </div>

  <div class="control-group">
    <label>BPM</label>
    <input type="range" id="bpm-slider" min="40" max="160" value="72">
    <span id="bpm-value">72</span>
  </div>

  <div class="control-group">
    <label>Transpose</label>
    <button id="btn-transpose-down">-</button>
    <span id="transpose-value">0</span>
    <button id="btn-transpose-up">+</button>
  </div>
</div>

<div id="song-display">
  <p class="no-song">Select a song to get started.</p>
</div>

<script type="importmap">
{
  "imports": {
    "songsheet": "../index.js",
    "tone": "https://esm.sh/tone@14"
  }
}
</script>

<script type="module">
import { parse, transpose } from 'songsheet'
import * as Tone from 'tone'

// ─── Chord-to-Notes Mapping ──────────────────────────────────────────

const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']
const NOTE_TO_SEMITONE = {}
const FLAT_MAP = { 'Db': 'C#', 'Eb': 'D#', 'Gb': 'F#', 'Ab': 'G#', 'Bb': 'A#' }

NOTE_NAMES.forEach((n, i) => NOTE_TO_SEMITONE[n] = i)
Object.entries(FLAT_MAP).forEach(([flat, sharp]) => NOTE_TO_SEMITONE[flat] = NOTE_TO_SEMITONE[sharp])

const CHORD_INTERVALS = {
  '':     [0, 4, 7],
  'm':    [0, 3, 7],
  '7':    [0, 4, 7, 10],
  'm7':   [0, 3, 7, 10],
  'maj7': [0, 4, 7, 11],
  'dim':  [0, 3, 6],
  'aug':  [0, 4, 8],
  'sus4': [0, 5, 7],
  'sus2': [0, 2, 7],
}

function chordToNotes(chord) {
  if (!chord || !chord.root) return null
  const rootSemitone = NOTE_TO_SEMITONE[chord.root]
  if (rootSemitone === undefined) return null
  const intervals = CHORD_INTERVALS[chord.type] || CHORD_INTERVALS['']
  return intervals.map(interval => {
    const semitone = (rootSemitone + interval) % 12
    const octave = semitone < rootSemitone ? 4 : 3
    return NOTE_NAMES[semitone] + octave
  })
}

// ─── State ───────────────────────────────────────────────────────────

let originalSong = null
let currentSong = null
let semitoneOffset = 0
let isPlaying = false
let synth = null
let clickSynth = null
let metronomeEnabled = false
let scheduledEvents = []

// ─── DOM refs ────────────────────────────────────────────────────────

const songSelect = document.getElementById('song-select')
const btnPlay = document.getElementById('btn-play')
const btnStop = document.getElementById('btn-stop')
const bpmSlider = document.getElementById('bpm-slider')
const bpmValue = document.getElementById('bpm-value')
const btnTransposeDown = document.getElementById('btn-transpose-down')
const btnTransposeUp = document.getElementById('btn-transpose-up')
const transposeValue = document.getElementById('transpose-value')
const btnMetronome = document.getElementById('btn-metronome')
const songDisplay = document.getElementById('song-display')

// ─── Song Loading & Rendering ────────────────────────────────────────

async function loadSong(filename) {
  const resp = await fetch('../' + filename)
  const text = await resp.text()
  originalSong = parse(text)
  semitoneOffset = 0
  transposeValue.textContent = '0'
  currentSong = originalSong
  renderSong(currentSong)
}

function chordName(chord) {
  if (!chord || !chord.root) return ''
  return chord.root + chord.type
}

function renderSong(song) {
  songDisplay.innerHTML = ''

  const titleEl = document.createElement('div')
  titleEl.id = 'song-title'
  titleEl.textContent = song.title
  songDisplay.appendChild(titleEl)

  const authorEl = document.createElement('div')
  authorEl.id = 'song-author'
  authorEl.textContent = song.author
  songDisplay.appendChild(authorEl)

  song.structure.forEach((entry, si) => {
    const sectionDiv = document.createElement('div')
    sectionDiv.className = 'section'
    sectionDiv.dataset.structureIndex = si

    // Section header
    const header = document.createElement('div')
    header.className = 'section-header'
    const label = entry.sectionType.charAt(0).toUpperCase() + entry.sectionType.slice(1)
    const indexLabel = entry.sectionIndex > 0 ? ' ' + (entry.sectionIndex + 1) : ''
    header.textContent = label + indexLabel
    sectionDiv.appendChild(header)

    if (entry.lines.length > 0) {
      // Entries with chord/lyric lines
      entry.lines.forEach((line, li) => {
        const pairDiv = document.createElement('div')
        pairDiv.className = 'line-pair'
        pairDiv.dataset.lineIndex = li

        if (line.chords.length > 0 || line.barLines.length > 0) {
          const chordRow = document.createElement('div')
          chordRow.className = 'chord-row'
          // Merge chords and bar lines, wrap each in a span for highlighting
          const markers = []
          for (const chord of line.chords) {
            markers.push({ col: chord.column, text: chordName(chord) })
          }
          for (const col of line.barLines) {
            markers.push({ col, text: '|' })
          }
          markers.sort((a, b) => a.col - b.col)
          let pos = 0
          markers.forEach((m, mi) => {
            if (m.col > pos) {
              chordRow.appendChild(document.createTextNode('\u00A0'.repeat(m.col - pos)))
            }
            const span = document.createElement('span')
            span.className = 'chord-marker'
            span.dataset.si = si
            span.dataset.li = li
            span.dataset.mi = mi
            span.textContent = m.text
            chordRow.appendChild(span)
            pos = m.col + m.text.length
          })
          pairDiv.appendChild(chordRow)
        }

        if (line.lyrics) {
          const lyricRow = document.createElement('div')
          lyricRow.className = 'lyric-row'
          lyricRow.textContent = line.lyrics
          pairDiv.appendChild(lyricRow)
        }

        sectionDiv.appendChild(pairDiv)
      })
    } else if (entry.chords.length > 0) {
      // Directive entries (instrumental, fill) — flat chord list with spans
      const chordDiv = document.createElement('div')
      chordDiv.className = 'directive-chords'
      entry.chords.forEach((c, ci) => {
        if (ci > 0) chordDiv.appendChild(document.createTextNode('  '))
        const span = document.createElement('span')
        span.className = 'chord-marker'
        span.dataset.si = si
        span.dataset.li = -1
        span.dataset.mi = ci
        span.textContent = chordName(c)
        chordDiv.appendChild(span)
      })
      if (entry.expression) {
        const exprSpan = document.createElement('span')
        exprSpan.className = 'expression-label'
        exprSpan.textContent = '  (' + expressionToString(entry.expression) + ')'
        chordDiv.appendChild(exprSpan)
      }
      sectionDiv.appendChild(chordDiv)
    }

    songDisplay.appendChild(sectionDiv)
  })
}

function expressionToString(expr) {
  if (!expr) return ''
  switch (expr.type) {
    case 'section_ref':
      return expr.name.toUpperCase()
    case 'chord_list':
      return expr.chords.map(c => chordName(c)).join(' ')
    case 'sequence':
      return expr.items.map(expressionToString).join(', ')
    case 'repeat':
      return expressionToString(expr.body) + '*' + expr.count
    default:
      return ''
  }
}

// ─── Synth & Playback ────────────────────────────────────────────────

function initSynth() {
  if (synth) synth.dispose()
  synth = new Tone.PolySynth(Tone.Synth, {
    maxPolyphony: 8,
    voice: Tone.Synth,
    options: {
      oscillator: { type: 'triangle' },
      envelope: { attack: 0.05, decay: 0.3, sustain: 0.4, release: 0.8 },
      volume: -8,
    }
  })
  synth.toDestination()

  if (clickSynth) clickSynth.dispose()
  clickSynth = new Tone.NoiseSynth({
    noise: { type: 'white' },
    envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.01 },
    volume: -12,
  })
  clickSynth.toDestination()
}

function collectAllChords(song) {
  // Returns flat list of { chord, structureIndex, lineIndex, markerIndex }
  // Bar lines add extra measures: "D |" → [D, D], "A C D | |" → [A, C, D, D, D]
  // markerIndex maps to the <span data-mi="..."> in the rendered chord row
  const result = []
  song.structure.forEach((entry, si) => {
    if (entry.lines.length > 0) {
      entry.lines.forEach((line, li) => {
        // Merge chords and bar lines sorted by column position
        const markers = []
        for (const chord of line.chords) {
          markers.push({ col: chord.column, type: 'chord', chord })
        }
        for (const col of line.barLines) {
          markers.push({ col, type: 'bar' })
        }
        markers.sort((a, b) => a.col - b.col)
        let currentChord = null
        markers.forEach((m, mi) => {
          if (m.type === 'chord') {
            currentChord = m.chord
            result.push({ chord: currentChord, structureIndex: si, lineIndex: li, markerIndex: mi })
          } else if (currentChord) {
            result.push({ chord: currentChord, structureIndex: si, lineIndex: li, markerIndex: mi })
          }
        })
      })
    } else {
      entry.chords.forEach((chord, ci) => {
        result.push({ chord, structureIndex: si, lineIndex: -1, markerIndex: ci })
      })
    }
  })
  return result
}

function scheduleSong(song) {
  Tone.getTransport().cancel()
  scheduledEvents = []

  const allChords = collectAllChords(song)
  if (allChords.length === 0) return

  const measureDur = Tone.Time('1n').toSeconds()
  const beatDur = Tone.Time('4n').toSeconds()

  allChords.forEach((item, i) => {
    const time = measureDur * i
    const eventId = Tone.getTransport().schedule(t => {
      const notes = chordToNotes(item.chord)
      if (notes && synth) {
        synth.triggerAttackRelease(notes, '2n', t)
      }
      Tone.getDraw().schedule(() => {
        highlightPosition(item.structureIndex, item.lineIndex, item.markerIndex)
      }, t)
    }, time)
    scheduledEvents.push(eventId)

    // Metronome: 4 clicks per measure (quarter notes)
    for (let beat = 0; beat < 4; beat++) {
      Tone.getTransport().schedule(t => {
        if (metronomeEnabled && clickSynth) {
          clickSynth.triggerAttackRelease('32n', t)
        }
      }, time + beatDur * beat)
    }
  })

  // Schedule end-of-song stop
  const endTime = Tone.Time('1n').toSeconds() * allChords.length
  Tone.getTransport().schedule(() => {
    Tone.getDraw().schedule(() => {
      stopPlayback()
    }, Tone.now())
  }, endTime)
}

async function startPlayback() {
  if (!currentSong || isPlaying) return

  await Tone.start()
  initSynth()
  Tone.getTransport().bpm.value = parseInt(bpmSlider.value, 10)
  Tone.getTransport().position = 0
  scheduleSong(currentSong)
  Tone.getTransport().start()

  isPlaying = true
  btnPlay.disabled = true
  btnStop.disabled = false
}

function stopPlayback() {
  Tone.getTransport().stop()
  Tone.getTransport().cancel()
  if (synth) synth.releaseAll()
  clearHighlight()
  isPlaying = false
  btnPlay.disabled = !currentSong
  btnStop.disabled = true
}

// ─── Highlighting ────────────────────────────────────────────────────

function clearHighlight() {
  document.querySelectorAll('.active-section').forEach(el => el.classList.remove('active-section'))
  document.querySelectorAll('.active-line').forEach(el => el.classList.remove('active-line'))
  document.querySelectorAll('.active-marker').forEach(el => el.classList.remove('active-marker'))
}

function highlightPosition(structureIndex, lineIndex, markerIndex) {
  clearHighlight()
  const sectionEl = songDisplay.querySelector(`.section[data-structure-index="${structureIndex}"]`)
  if (!sectionEl) return
  sectionEl.classList.add('active-section')

  if (lineIndex >= 0) {
    const lineEl = sectionEl.querySelector(`.line-pair[data-line-index="${lineIndex}"]`)
    if (lineEl) lineEl.classList.add('active-line')
  }

  // Highlight the specific chord or bar-line marker
  const marker = songDisplay.querySelector(
    `.chord-marker[data-si="${structureIndex}"][data-li="${lineIndex}"][data-mi="${markerIndex}"]`
  )
  if (marker) marker.classList.add('active-marker')

  sectionEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' })
}

// ─── Transpose ───────────────────────────────────────────────────────

function applyTranspose(delta) {
  if (!originalSong) return
  semitoneOffset += delta
  transposeValue.textContent = (semitoneOffset >= 0 ? '+' : '') + semitoneOffset
  if (semitoneOffset === 0) transposeValue.textContent = '0'
  currentSong = semitoneOffset === 0 ? originalSong : transpose(originalSong, semitoneOffset)
  renderSong(currentSong)
  if (isPlaying) {
    // Re-schedule with new chords, keep transport running
    scheduleSong(currentSong)
  }
}

// ─── Event Wiring ────────────────────────────────────────────────────

songSelect.addEventListener('change', async () => {
  if (isPlaying) stopPlayback()
  if (songSelect.value) {
    btnPlay.disabled = true
    await loadSong(songSelect.value)
    btnPlay.disabled = false
  } else {
    originalSong = null
    currentSong = null
    songDisplay.innerHTML = '<p class="no-song">Select a song to get started.</p>'
    btnPlay.disabled = true
  }
})

btnPlay.addEventListener('click', startPlayback)
btnStop.addEventListener('click', stopPlayback)

bpmSlider.addEventListener('input', () => {
  bpmValue.textContent = bpmSlider.value
  Tone.getTransport().bpm.value = parseInt(bpmSlider.value, 10)
})

btnTransposeDown.addEventListener('click', () => applyTranspose(-1))
btnTransposeUp.addEventListener('click', () => applyTranspose(1))

btnMetronome.addEventListener('click', () => {
  metronomeEnabled = !metronomeEnabled
  btnMetronome.classList.toggle('on', metronomeEnabled)
})

// Initial state
btnPlay.disabled = true
</script>

</body>
</html>
